package io.requery.android.sqlite;

import android.annotation.SuppressLint;
import com.google.android.exoplayer2.C;
import com.google.common.base.Ascii;
import java.io.InputStream;
import java.io.Reader;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.net.URL;
import java.sql.Array;
import java.sql.Blob;
import java.sql.Clob;
import java.sql.Date;
import java.sql.NClob;
import java.sql.ParameterMetaData;
import java.sql.PreparedStatement;
import java.sql.Ref;
import java.sql.ResultSetMetaData;
import java.sql.RowId;
import java.sql.SQLException;
import java.sql.SQLFeatureNotSupportedException;
import java.sql.SQLXML;
import java.sql.Time;
import java.sql.Timestamp;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.TimeZone;

@SuppressLint({"SimpleDateFormat"})
public abstract class BasePreparedStatement extends BaseStatement implements PreparedStatement {
    static final ThreadLocal<DateFormat> ISO8601_FORMAT = new ThreadLocal<DateFormat>() {
        /* access modifiers changed from: protected */
        public DateFormat initialValue() {
            SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'");
            simpleDateFormat.setTimeZone(TimeZone.getTimeZone("UTC"));
            return simpleDateFormat;
        }
    };
    private static final char[] hex = "0123456789ABCDEF".toCharArray();
    protected final int autoGeneratedKeys;
    protected List<Object> bindings;
    private Map<Integer, byte[]> blobLiterals;
    private String sql;

    /* access modifiers changed from: protected */
    public abstract void bindBlob(int i, byte[] bArr);

    /* access modifiers changed from: protected */
    public abstract void bindDouble(int i, double d);

    /* access modifiers changed from: protected */
    public abstract void bindLong(int i, long j);

    /* access modifiers changed from: protected */
    public abstract void bindNullOrString(int i, Object obj);

    public ResultSetMetaData getMetaData() throws SQLException {
        return null;
    }

    public ParameterMetaData getParameterMetaData() throws SQLException {
        return null;
    }

    protected BasePreparedStatement(BaseConnection baseConnection, String str, int i) throws SQLException {
        super(baseConnection);
        if (str != null) {
            if (i != 1) {
                this.bindings = new ArrayList(4);
            }
            this.sql = str;
            this.autoGeneratedKeys = i;
            return;
        }
        throw new SQLException("null sql");
    }

    /* access modifiers changed from: protected */
    public String[] bindingsToArray() {
        String[] strArr = new String[this.bindings.size()];
        for (int i = 0; i < this.bindings.size(); i++) {
            Object obj = this.bindings.get(i);
            if (obj != null) {
                strArr[i] = obj.toString();
            }
        }
        return strArr;
    }

    private static String byteToHexString(byte[] bArr) {
        StringBuilder sb = new StringBuilder(bArr.length * 2);
        for (byte b : bArr) {
            sb.append(hex[(b >> 4) & 15]);
            sb.append(hex[b & Ascii.SI]);
        }
        return sb.toString();
    }

    /* access modifiers changed from: protected */
    public void bindBlobLiteral(int i, byte[] bArr) {
        if (this.blobLiterals == null) {
            this.blobLiterals = new LinkedHashMap();
        }
        this.blobLiterals.put(Integer.valueOf(i), bArr);
    }

    private String inlineBlobLiterals() {
        StringBuilder sb = new StringBuilder();
        String[] split = this.sql.split("\\?");
        int i = 0;
        while (i < split.length) {
            sb.append(split[i]);
            int i2 = i + 1;
            if (this.blobLiterals.containsKey(Integer.valueOf(i2))) {
                sb.append("x'");
                sb.append(byteToHexString((byte[]) this.blobLiterals.get(Integer.valueOf(i2))));
                sb.append("'");
            } else if (i < split.length - 1) {
                sb.append("?");
            }
            i = i2;
        }
        return sb.toString();
    }

    /* access modifiers changed from: protected */
    public String getSql() {
        Map<Integer, byte[]> map = this.blobLiterals;
        if (map == null || map.values().isEmpty()) {
            return this.sql;
        }
        return inlineBlobLiterals();
    }

    public void addBatch() throws SQLException {
        throw new SQLFeatureNotSupportedException();
    }

    public void setArray(int i, Array array) throws SQLException {
        throw new SQLFeatureNotSupportedException();
    }

    public void setAsciiStream(int i, InputStream inputStream, int i2) throws SQLException {
        throw new SQLFeatureNotSupportedException();
    }

    public void setBigDecimal(int i, BigDecimal bigDecimal) throws SQLException {
        bindNullOrString(i, bigDecimal);
    }

    public void setBinaryStream(int i, InputStream inputStream, int i2) throws SQLException {
        throw new SQLFeatureNotSupportedException();
    }

    public void setBlob(int i, Blob blob) throws SQLException {
        setBytes(i, blob.getBytes(0, (int) blob.length()));
    }

    public void setBoolean(int i, boolean z) throws SQLException {
        bindLong(i, z ? 1 : 0);
    }

    public void setByte(int i, byte b) throws SQLException {
        bindLong(i, (long) b);
    }

    public void setBytes(int i, byte[] bArr) throws SQLException {
        bindBlob(i, bArr);
    }

    public void setCharacterStream(int i, Reader reader, int i2) throws SQLException {
        throw new SQLFeatureNotSupportedException();
    }

    public void setClob(int i, Clob clob) throws SQLException {
        throw new SQLFeatureNotSupportedException();
    }

    public void setDate(int i, Date date) throws SQLException {
        setDate(i, date, null);
    }

    public void setDate(int i, Date date, Calendar calendar) throws SQLException {
        bindNullOrString(i, date == null ? null : ((DateFormat) ISO8601_FORMAT.get()).format(date));
    }

    public void setDouble(int i, double d) throws SQLException {
        bindDouble(i, d);
    }

    public void setFloat(int i, float f) throws SQLException {
        bindDouble(i, (double) f);
    }

    public void setInt(int i, int i2) throws SQLException {
        bindLong(i, (long) i2);
    }

    public void setLong(int i, long j) throws SQLException {
        bindLong(i, j);
    }

    public void setNull(int i, int i2) throws SQLException {
        bindNullOrString(i, null);
    }

    public void setNull(int i, int i2, String str) throws SQLException {
        bindNullOrString(i, null);
    }

    public void setObject(int i, Object obj) throws SQLException {
        if (obj == null) {
            setNull(i, 0);
        } else if (obj instanceof String) {
            setString(i, obj.toString());
        } else if (obj instanceof Byte) {
            setByte(i, ((Byte) obj).byteValue());
        } else if (obj instanceof Short) {
            setShort(i, ((Short) obj).shortValue());
        } else if (obj instanceof Integer) {
            setInt(i, ((Integer) obj).intValue());
        } else if (obj instanceof Long) {
            setLong(i, ((Long) obj).longValue());
        } else if (obj instanceof Double) {
            setDouble(i, ((Double) obj).doubleValue());
        } else if (obj instanceof Float) {
            setFloat(i, ((Float) obj).floatValue());
        } else if (obj instanceof Boolean) {
            setLong(i, ((Boolean) obj).booleanValue() ? 1 : 0);
        } else if (obj instanceof byte[]) {
            setBytes(i, (byte[]) obj);
        } else if (obj instanceof Date) {
            setDate(i, (Date) obj);
        } else if (obj instanceof java.util.Date) {
            setDate(i, new Date(((java.util.Date) obj).getTime()));
        } else if (obj instanceof BigDecimal) {
            setBigDecimal(i, (BigDecimal) obj);
        } else {
            StringBuilder sb = new StringBuilder();
            sb.append("unhandled type ");
            sb.append(obj.getClass().getCanonicalName());
            throw new SQLException(sb.toString());
        }
    }

    public void setObject(int i, Object obj, int i2) throws SQLException {
        String str;
        if (obj == null || i2 == 0) {
            setNull(i, 0);
            return;
        }
        if (i2 == -9 || i2 == 12) {
            if (obj instanceof String) {
                str = (String) obj;
            } else {
                str = obj.toString();
            }
            setString(i, str);
        } else if (i2 == 16) {
            setBoolean(i, ((Boolean) obj).booleanValue());
        } else if (i2 != 91) {
            if (i2 != 93) {
                if (i2 != 2004) {
                    switch (i2) {
                        case -6:
                            if (obj instanceof Byte) {
                                bindLong(i, ((Byte) obj).longValue());
                                break;
                            }
                            break;
                        case C.RESULT_FORMAT_READ /*-5*/:
                            if (obj instanceof BigInteger) {
                                bindNullOrString(i, ((BigInteger) obj).toString());
                                break;
                            }
                            break;
                        default:
                            switch (i2) {
                                case -3:
                                case -2:
                                    break;
                                default:
                                    switch (i2) {
                                        case 3:
                                            if (obj instanceof BigDecimal) {
                                                setBigDecimal(i, (BigDecimal) obj);
                                                break;
                                            }
                                            break;
                                        case 4:
                                        case 5:
                                            if (!(obj instanceof Integer)) {
                                                if (!(obj instanceof Long)) {
                                                    if (obj instanceof Short) {
                                                        bindLong(i, ((Short) obj).longValue());
                                                        break;
                                                    }
                                                } else {
                                                    bindLong(i, ((Long) obj).longValue());
                                                    break;
                                                }
                                            } else {
                                                bindLong(i, ((Integer) obj).longValue());
                                                break;
                                            }
                                            break;
                                        case 6:
                                        case 7:
                                        case 8:
                                            if (!(obj instanceof Double)) {
                                                if (obj instanceof Float) {
                                                    setFloat(i, ((Float) obj).floatValue());
                                                    break;
                                                }
                                            } else {
                                                setDouble(i, ((Double) obj).doubleValue());
                                                break;
                                            }
                                            break;
                                        default:
                                            StringBuilder sb = new StringBuilder();
                                            sb.append("unhandled type ");
                                            sb.append(i2);
                                            throw new SQLException(sb.toString());
                                    }
                            }
                    }
                }
                setBytes(i, (byte[]) obj);
            } else if (obj instanceof Timestamp) {
                setLong(i, ((Timestamp) obj).getTime());
            }
        } else if (obj instanceof Date) {
            setLong(i, ((Date) obj).getTime());
        } else if (obj instanceof java.util.Date) {
            setLong(i, ((java.util.Date) obj).getTime());
        }
    }

    public void setObject(int i, Object obj, int i2, int i3) throws SQLException {
        throw new SQLFeatureNotSupportedException();
    }

    public void setRef(int i, Ref ref) throws SQLException {
        throw new SQLFeatureNotSupportedException();
    }

    public void setShort(int i, short s) throws SQLException {
        bindLong(i, (long) s);
    }

    public void setString(int i, String str) throws SQLException {
        bindNullOrString(i, str);
    }

    public void setTime(int i, Time time) throws SQLException {
        if (time == null) {
            bindNullOrString(i, null);
        } else {
            bindLong(i, time.getTime());
        }
    }

    public void setTime(int i, Time time, Calendar calendar) throws SQLException {
        if (time == null) {
            bindNullOrString(i, null);
        } else {
            bindLong(i, time.getTime());
        }
    }

    public void setTimestamp(int i, Timestamp timestamp) throws SQLException {
        if (timestamp == null) {
            bindNullOrString(i, null);
        } else {
            bindLong(i, timestamp.getTime());
        }
    }

    public void setTimestamp(int i, Timestamp timestamp, Calendar calendar) throws SQLException {
        if (timestamp == null) {
            bindNullOrString(i, null);
        } else {
            bindLong(i, timestamp.getTime());
        }
    }

    public void setUnicodeStream(int i, InputStream inputStream, int i2) throws SQLException {
        throw new SQLFeatureNotSupportedException();
    }

    public void setURL(int i, URL url) throws SQLException {
        bindNullOrString(i, url);
    }

    public void setRowId(int i, RowId rowId) throws SQLException {
        throw new SQLFeatureNotSupportedException();
    }

    public void setNString(int i, String str) throws SQLException {
        bindNullOrString(i, str);
    }

    public void setNCharacterStream(int i, Reader reader, long j) throws SQLException {
        throw new SQLFeatureNotSupportedException();
    }

    public void setNClob(int i, NClob nClob) throws SQLException {
        throw new SQLFeatureNotSupportedException();
    }

    public void setClob(int i, Reader reader, long j) throws SQLException {
        throw new SQLFeatureNotSupportedException();
    }

    public void setBlob(int i, InputStream inputStream, long j) throws SQLException {
        throw new SQLFeatureNotSupportedException();
    }

    public void setNClob(int i, Reader reader, long j) throws SQLException {
        throw new SQLFeatureNotSupportedException();
    }

    public void setSQLXML(int i, SQLXML sqlxml) throws SQLException {
        throw new SQLFeatureNotSupportedException();
    }

    public void setAsciiStream(int i, InputStream inputStream, long j) throws SQLException {
        throw new SQLFeatureNotSupportedException();
    }

    public void setBinaryStream(int i, InputStream inputStream, long j) throws SQLException {
        throw new SQLFeatureNotSupportedException();
    }

    public void setCharacterStream(int i, Reader reader, long j) throws SQLException {
        throw new SQLFeatureNotSupportedException();
    }

    public void setAsciiStream(int i, InputStream inputStream) throws SQLException {
        throw new SQLFeatureNotSupportedException();
    }

    public void setBinaryStream(int i, InputStream inputStream) throws SQLException {
        throw new SQLFeatureNotSupportedException();
    }

    public void setCharacterStream(int i, Reader reader) throws SQLException {
        throw new SQLFeatureNotSupportedException();
    }

    public void setNCharacterStream(int i, Reader reader) throws SQLException {
        throw new SQLFeatureNotSupportedException();
    }

    public void setClob(int i, Reader reader) throws SQLException {
        throw new SQLFeatureNotSupportedException();
    }

    public void setBlob(int i, InputStream inputStream) throws SQLException {
        throw new SQLFeatureNotSupportedException();
    }

    public void setNClob(int i, Reader reader) throws SQLException {
        throw new SQLFeatureNotSupportedException();
    }

    public String toString() {
        return this.sql;
    }
}
